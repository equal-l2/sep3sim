     . = 0xF800
     ; 動作テスト
     MOV #65504, R0  
     ADD #1, R6     ; スタックを1つあげて出力領域を作る
     MOV (R0), (R6)+; MMIOをスタックに積む
     JSR FIB        ; FIB
     SUB #2, R6     ; 戻り値の領域までSPをずらす
     MOV (R6), (R0)     ; MMIOで戻り値を表示
     HLT

; フィボナッチ数計算手続
; (R6-1) : リターンアドレス
; (R6-2) : 戻り値
; (R6-3) : 引数
; R0: アドレス
; R1: 引数のコピー
; R2: 結果

FIB: ; レジスタ退避
     MOV R0, (R6)+
     MOV R1, (R6)+
     MOV R2, (R6)+

     ; 入力をR1へ入れる
     MOV R6, R0    ; スタックのアドレスをコピー
     SUB #5, R0    ; 入力のアドレスまでずらす
                   ; (上でレジスタをスタックに退避してしまったので
                   ; その分を考える)
     MOV (R0), R1  ; 引数をR1へコピー
     ADD #5, R0    ; R0は元の値に戻しておく

     ; 引数チェック
     SUB #1, R1    ; R1 = N - 1
     RBZ ONE
     SUB #1, R1    ; R1 = N - 2
     RBZ ONE

     ; 再帰呼出
     CLR R2        ; R2はADDで変更するので0にしておく

     ; FIB(N-2)の計算
     ADD #1, R6    ; スタックを1つあげて戻り値の領域を作る
     MOV R1, (R6)+ ; N-2をスタックに積む
     JSR FIB       ; FIB(N-2)
     SUB #2, R6    ; 戻り値の領域までSPをずらす
     ADD (R6), R2  ; 戻り値をR2へ足す

     ; FIB(N-1)の計算
     ADD #1, R1    ; R1 -> N-1
     ADD #1, R6    ; スタックを1つあげて戻り値の領域を作る
     MOV R1, (R6)+ ; N-1をスタックに積む
     JSR FIB       ; FIB(N-1)
     SUB #2, R6    ; 戻り値の領域までSPをずらす
     ADD (R6), R2  ; 戻り値をR2へ足す
     RJP FIN

ONE: MOV #1, R2
FIN: ; 結果をスタックの指定位置に入れる
     SUB #6, R0   ; 戻り値の領域まで下がる
     MOV R2, (R0)
     ; もうR0は使わないので復帰はしない

     ; レジスタ復帰
     MOV -(R6), R2
     MOV -(R6), R1
     MOV -(R6), R0

     ; 終わり
     RET
